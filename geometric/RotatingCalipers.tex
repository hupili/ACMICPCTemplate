\subsection{旋转卡壳}
    “对踵”\\
    \subsubsection{单个凸包}
	\begin{lstlisting}[language=c++]
void solve(Point p[],int n)
{
    Point v;
    int cur = 1;
    for (int i = 0;i < n;i++)
    {
        v = p[i]-p[(i+1)%n];
        while (v*(p[(cur+1)%n]-p[cur]) < 0)
            cur = (cur+1)%n;
        //p[cur] -> p[i]
        //p[cur] -> p[i+1]
        //p[cur] -> (p[i],p[i+1])
    }
}
	\end{lstlisting}
    \subsubsection{两个凸包}
	注意初始点的选取，代码只是个示例。\\
	有时候答案需要取solve(p0,n,p1,m)和solve(p1,m,p0,n)的最优值。\\
	\begin{lstlisting}[language=c++]
void solve(Point p0[],int n,Point p1[],int m)
{
    Point v;
    int cur = 0;
    for (int i = 0;i < n;i++)
    {
        v = p0[i]-p0[(i+1)%n];
        while (v*(p1[(cur+1)%m]-p1[cur]) < 0)
            cur = (cur+1)%m;
        //p1[cur] -> p0[i]
        //p1[cur] -> p0[i+1]
        //p1[cur] -> (p0[i],p0[i+1])
    }
}
	\end{lstlisting}